//=========================================================================================================================
// Optional
//=========================================================================================================================
HEADER
{
	CompileTargets = ( IS_SM_50 && ( PC || VULKAN ) );
	Description = "Sniper scope shader";
}

//=========================================================================================================================
// Optional
//=========================================================================================================================
FEATURES
{
    #include "common/features.hlsl"
}

//=========================================================================================================================
// Optional
//=========================================================================================================================
MODES
{
	VrForward();													// Indicates this shader will be used for main rendering
	Depth( "vr_depth_only.vfx" ); 									// Shader that will be used for shadowing and depth prepass
	ToolsVis( S_MODE_TOOLS_VIS ); 									// Ability to see in the editor
	ToolsWireframe( "vr_tools_wireframe.vfx" ); 					// Allows for mat_wireframe to work
	ToolsShadingComplexity( "vr_tools_shading_complexity.vfx" ); 	// Shows how expensive drawing is in debug view
}

//=========================================================================================================================
COMMON
{
	#include "common/shared.hlsl"
    #define S_TRANSLUCENT 1
    #define BLEND_MODE_ALREADY_SET
}

//=========================================================================================================================

struct VertexInput
{
	#include "common/vertexinput.hlsl"
};

//=========================================================================================================================

struct PixelInput
{
	#include "common/pixelinput.hlsl"
};

//=========================================================================================================================

VS
{
	#include "common/vertex.hlsl"
	//
	// Main
	//
	PixelInput MainVs( INSTANCED_SHADER_PARAMS( VS_INPUT i ) )
	{
		PixelInput o = ProcessVertex( i );
		// Add your vertex manipulation functions here
		return FinalizeVertex( o );
	}
}

//=========================================================================================================================

PS
{
  	// #include "common/pixel.hlsl"
    // #include "common.fxc"
	#include "vr_shared_standard_ps_code.fxc"
	  
    RenderState( BlendEnable, true );
    RenderState( SrcBlend, SRC_ALPHA );
    RenderState( DstBlend, INV_SRC_ALPHA );
    RenderState(AlphaToCoverageEnable, true);

    CreateInputTexture2D( ReticleTexture, Srgb, 8, "", "",  "Textures", Default3( 1, 1, 1 ) );
    CreateTexture2D( g_tReticle ) < Channel( RGBA, None( ReticleTexture ), Srgb ); OutputFormat( DXT5 ); SrgbRead( true ); >;
    TextureAttribute( g_tReticle, g_tReticle );

    CreateTexture2D( g_tScopeRT ) < Attribute( "ScopeRT" ); SrgbRead( false ); Filter( MIN_MAG_MIP_LINEAR );  >;

	float g_flReticleScale < UiType( Slider ); Default( 2.5f ); UiGroup( "Reticle" ); >;
	float2 g_flReticleOffset < UiType( Slider ); Default2( 0.25f, 0.79f ); UiGroup( "Reticle" ); Range2( 0.0f, 0.0f, 1.0f, 1.0f ); >;
	float g_flReticleCircleScale < UiType( Slider ); Default( 2.0f ); UiGroup( "Reticle" ); >;

	float g_flMaskStrength < UiType( Slider ); Default( 0.5f ); UiGroup( "Mask" ); >;
	float g_flMaskPower < UiType( Slider ); Default( 2.0f ); UiGroup( "Mask" ); >;
	
	float2 g_flMaskOffset < UiType( Slider ); Default2( 0.0f, 0.0f ); UiGroup( "Mask" ); Range2( -1.0f, -1.0f, 1.0f, 1.0f ); >;

	//
	// Main
	//
	PS_OUTPUT MainPs( PixelInput i )
	{
		FinalCombinerInput_t material = PS_SharedStandardProcessing( i );

		PS_OUTPUT o = PS_FinalCombiner( material );
        float2 vPositionUvWithOffset = ( ( i.vPositionSs.xy ) - g_vViewportOffset ) / g_vRenderTargetSize;
        float fAspectRatio = g_vViewportSize.y / g_vViewportSize.x;

		//
		// Circle mask
		//
		float2 vCircleMaskUvs = (vPositionUvWithOffset - 0.5f) * float2( 1.0f, fAspectRatio );
		vCircleMaskUvs += g_flMaskOffset;
		float fMaskMix = 1.0f - saturate( pow( length( vCircleMaskUvs * g_flMaskStrength ), g_flMaskPower ) );

		//
		// Reticle texture
		//
        float2 vPositionUv = ( i.vPositionSs.xy - g_vViewportOffset ) / g_vRenderTargetSize;
        float2 vReticleUvs = float2( vPositionUv.x, ( vPositionUv.y * fAspectRatio ) ) * g_flReticleScale;
        vReticleUvs += g_flReticleOffset;
        float4 vReticleColor = Tex2D( g_tReticle, vReticleUvs );

		//
		// Put it all together
		//
		o.vColor = Tex2D( g_tScopeRT, vPositionUvWithOffset * pow( fMaskMix, 0.025f ) );
        o.vColor.xyz = SrgbGammaToLinear( o.vColor.xyz * vReticleColor.xyz );
		o.vColor.xyz *= fMaskMix;
		o.vColor.z *= pow( fMaskMix, 2 ); // We want the outer edge to look green/yellow

        o.vColor.a = 1.0;
		return o;
	}
}